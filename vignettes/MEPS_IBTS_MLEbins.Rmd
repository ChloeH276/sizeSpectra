---
title: "MEPS_IBTS_MLEbins"
author: "Andrew Edwards"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MEPS_IBTS_MLEbins}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5.7,
  fig.height = 7
)
```

# Analyses of IBTS data using the MLEbins method

This vignette analyses the IBTS data using the MLEbins method that explicitly accounts for
the species-specific body-mass bins.

Creates Figure 6 (and related Figures S.1, S.2 and S.3) showing
species-specific body mass bins resulting from the length bins, Figure 8
(comparison of MLE and MLEbins values of b through time) and MLEbins row of
Table S.1.

```{r}
library(sizeSpectra)
data = IBTS_data
data
```
<!-- From nSeaMLEbins.Snw, removing what isn't needed. Took this from -->
<!-- fitting-size-spectra repo, think I took earlier ones from manuscript2 -->

TODO: And see what to save in data-raw/IBTS-MLEbins.R, copy those lines to end of here


```{r}
# require(xtable)
# require(gplots)                 # for plotCI
```

TODO - put into earlier vignette
```{r}
specCodeNames                  # species names and id's. But there are more
                               #  species in the data than here (see later)
length(unique(specCodeNames$speccode))   # checking speccode are unique
```

## Determining which rows are 0.5 cm bins

`LngtClass` for all species is the minimum value of a 1-cm-width bin, except for
herring (*Clupea harengus*) and sprat (*Sprattus sprattus*) for which lengths
are rounded down to 0.5 cm values (bins are 0.5-cm wide). The `SpecCode` values for these:

```{r speciesNames}
herringCode = dplyr::filter(specCodeNames, species == "Clupea harengus")$speccode
herringCode
spratCode = dplyr::filter(specCodeNames, species == "Sprattus sprattus")$speccode
spratCode
``

TODO: this may have been done in earlier vignette - delete one or the other,
this seems concise and is appropriate here.

Verify that: (i) these species codes do have 0.5 cm values for `LngtClass`, and
(ii) that no other species codes have 0.5 cm values for `LngtClass`.

```{r verify}
herring = dplyr::filter(data, SpecCode == herringCode)
unique(herring$LngtClass)
sprat = dplyr::filter(data, SpecCode == spratCode)
unique(sprat$LngtClass)
```

So, yes, both have 0.5 cm length classes.

```{r verify2}
specCode05 = c(herringCode, spratCode)      # species codes with 0.5cm length bins
others = dplyr::filter(data, !SpecCode %in% specCode05)
sort(unique(others$LngtClass))
```

Can visually see that there are no 0.5 values, confirming that just the two
species have the 0.5-cm length bins.

## Append the max of the bin breaks for each row

So `LngtClass` is the minimum of each length bin. Need to work out the maximum
of each length bin `LengthMax`, and then use the species-specific length-weight
relationships to give the min (`wmin`) and max (`wmax`) of each body-mass bin.
So create `dataBin` table dataframe that has `LengthMax`, `wmin` and `wmax` as
extra columns for each row:

```{r dataBin}
dataBin = dplyr::mutate(data,
                        LngtMax = LngtClass + 1)
aa = which(dataBin$SpecCode %in% specCode05)           # row numbers for herring, sprat
dataBin[aa, "LngtMax"] = dataBin[aa, "LngtMax"] - 0.5  # subtract 0.5 cm to
                                                       # give 0.5-cm wide bins
unique(dataBin$LngtMax - dataBin$LngtClass)            # correctly just has 0.5 and 1
unique( dplyr::filter(dataBin, LngtMax - LngtClass == 0.5)$SpecCode)  # just herring,sprat

dataBin = dplyr::mutate(dataBin, wmax = LWa * LngtMax^LWb)  # calculate max body mass
                                                            # for each bin (min
                                                            # is currently bodyMass)
dataBin = dplyr::rename(dataBin, LngtMin = LngtClass)       # For consistency
dataBin = dplyr::rename(dataBin, wmin = bodyMass)

dataBin = dataBin[ , c("Year", "SpecCode", "LngtMin", "LngtMax",
                       "LWa", "LWb", "wmin", "wmax", "Number")]     # Reorder columns

range(dplyr::mutate(dataBin, wminCheck = LWa * LngtMin^LWb)$wminCheck - dataBin$wmin)
                                              # Verifying that wmin is correct
                                              # (was calculated independently)
length(unique(dataBin$SpecCode))
@

## Plot the resulting body mass bins

So there are `r length(unique(dataBin$SpecCode))` uniques species. Now going to
plot the resulting body mass bins for each species, with 45 on each figure. This
gives Figures 6, S.1, S.2 and S.3. First wrangle the data and calculate some
useful values:

```{r}
# Just need the species-specific bodymass bins, don't need
#  Year, length info or Number.
dataBinSpec = dplyr::summarise(dplyr::group_by(dataBin, SpecCode, wmin),
                               wmax = unique(wmax))
# Arrange species in order of their max(wmax)

dataBinSpecWmax = dplyr::summarise(dplyr::group_by(dataBinSpec, SpecCode),
                                   maxWmax = max(wmax))
dataBinSpecWmax = dplyr::ungroup(dataBinSpecWmax)
dataBinSpecWmax = dplyr::arrange(dataBinSpecWmax, maxWmax)   # Species in order of maxWmax
dataBinSpec = dplyr::ungroup(dataBinSpec)
# http://stackoverflow.com/questions/26548495/reorder-rows-using-custom-order
# Create levels in the desired order
dataBinSpec = dplyr::mutate(dataBinSpec,
                            SpecCode = factor(SpecCode,
                                              levels = dataBinSpecWmax$SpecCode))
dataBinSpec = dplyr::arrange(dataBinSpec, SpecCode)

uniqBinSpecCode = levels(dataBinSpec$SpecCode) # species codes in
                                               #  the desired order

# species in the data (in order of figures) but with no name (just to avoid
#  highlighting in figures):
specIDnoName = setdiff(uniqBinSpecCode, specCodeNames$speccode)
# species with names but not in data (not so important):
# specNotInData = setdiff(specCodeNames$speccode, uniqBinSpecCode)

# max number of bins for any species:
maxNumBins = max(dplyr::summarise(dplyr::group_by(dataBinSpec,
                                                  SpecCode),
                                  numBins = length(unique(wmin)))$numBins)

dataBinSpec = dplyr::mutate(dataBinSpec,
                            wWidth = wmax - wmin,
                            wWidthRatio = wWidth/wmin)
          # wWidth is width of body-mass bin, wWidthRatio is ratio to wmin
rowMaxWidth = which.max(dataBinSpec$wWidth)
specCodeMaxWidth = dataBinSpec[rowMaxWidth, ]$SpecCode
specNameMaxWidth = dplyr::filter(specCodeNames, speccode ==  specCodeMaxWidth)$species

rowMaxRatio = which.max(dataBinSpec$wWidthRatio)
specCodeMaxRatio = dataBinSpec[rowMaxRatio, ]$SpecCode
specNameMaxRatio = dplyr::filter(specCodeNames, speccode ==  specCodeMaxRatio)$species
dataBinMaxRatio = dplyr::filter(dataBin,
                                SpecCode == specCodeMaxRatio,
                                wmin == dataBinSpec[rowMaxRatio, ]$"wmin")
                                   # original data row(s) for maxRatio. "wmin"
                                   #  needed since wmin appears in dataBin also
```

Now create the figures:
```{r}
col = c("blue", "lightblue")     # Colours for bins
colHighlight = c("red", "pink")  # Colours for herring and sprat

thick = 7                           # thickness of bins

# Doing 3 figures, each with 135/3 = 45 species. Then a fourth that is
#  just some of the third one.
numSpec = 45                   # Number of species in a figure
specVecStart = c(1, 1 + numSpec, 1 + 2*numSpec, 1 + 2*numSpec)  # start species for fig
specVecEnd = specVecStart + numSpec - 1
specVecEnd[4] = specVecStart[4] + 37 - 1
                               # species 126447, as seen in Fig S.2 (not automated)
                               #  is the largest one below 10kg, to make Fig S.3

smallTicks = c(2, 20, 1000, 200)        # location of small ticks for fig.num
medTicks = c(10, 100, 5000, 1000)       # location of medium (unlabelled) ticks

xLimMax = c(10, 10, 10, specVecEnd/numSpec * 10)

specCodeHighlight = c(127205, 154675)
                                   #  now doing two for first figure for
                                   #  manuscript. Plus 127251 for Figure A.4 done
                                   #  within loop.

for(fig.num in 1:4)      # doing 3 figures
    {
    specForFig = uniqBinSpecCode[ specVecStart[fig.num]:specVecEnd[fig.num] ]
    xVals = seq(0.2,
                xLimMax[fig.num]-0.2,
                length=length(specForFig))  # xvals for vertical mass bins

    yLim = 1.02*max(dplyr::filter(dataBinSpec,
                                  SpecCode %in% specForFig)$wmax)
    # postscript(paste("nSeaFungBins", fig.num, ".eps", sep=""),
    #        height = 6, width = 7.5,
    #        horizontal=FALSE,  paper="special")

    par(xaxs="i", yaxs="i")
    par(mgp=c(2.0, 0.5, 0))    # puts axes labels closer
    par(lend="butt")           # To have butted line caps, need for thick lines.

    plot(0,
         0,
         xlab="",
         ylab="Body mass, g",
         xlim=c(0, xLimMax[fig.num]),
         ylim=c(0, yLim),
         xaxt="n",
         type="n")      # dummy points to set up axes.

    # Adding horizontal grey lines:
    axis(2,
         at = seq(0, yLim, by=medTicks[fig.num]),
         labels=rep("", length(seq(0, yLim, by=medTicks[fig.num]))),
         tck=1,
         col="lightgrey")
    # Add extra tick marks:
    axis(2,
         at = seq(0, yLim, by=smallTicks[fig.num]),
         labels=rep("", length(seq(0, yLim, by=smallTicks[fig.num]))),
         tck=-0.01)
    axis(2,
         at = seq(0, yLim, by=medTicks[fig.num]),
         labels=rep("", length(seq(0, yLim, by=medTicks[fig.num]))),
         tck=-0.02)
    # Add species codes:
    axis(1,
         at = xVals,
         labels = as.numeric(specForFig),
         las = 2,
         tck = -0.005, cex.axis=0.8)
    mtext("Species Code", side=1, line=3, cex.lab=1)
    abline(h=0)

    for(ii in 1:length(specForFig))   # loop over species, plot bins for each
        {
        xVal = xVals[ii]         # where to have vertical bars
        if(as.numeric(specForFig[ii]) %in% specCodeHighlight)
            { colSpec = colHighlight } else { colSpec = col}

        segments(x0 = xVal,
                 y0 = dplyr::filter(dataBinSpec,
                                    SpecCode == specForFig[ii])$wmin,
                 y1 = dplyr::filter(dataBinSpec,
                                    SpecCode == specForFig[ii])$wmax,
                 col=colSpec,       # recycles colours
                 lwd=thick)
        }
    par(xpd=TRUE)                   # allow plotting outside main region
    if(fig.num == 1)
      {
        points( xVals[which(as.numeric(specForFig) %in% specCode05)],
               -rep(0.015, length(specCode05))*yLim,
               pch=4,
               cex=0.96)            # indicate two species in Fig 6
      }

    if(fig.num == 4)
      {
        points( xVals[which(as.numeric(specForFig) == 127251)],
           -0.015*yLim, pch=4, cex=0.96) # indicate one species in Fig S.3
      }
    # dev.off()
}
```


Those four figures show how the length bins for each species get converted to
body mass bins. The conversions are different for each species because of the
different values of the length-weight coefficients. Even with 1-cm length bins
(and 0.5-cm for herring and sprat) the resulting body-mass bins can span a large
range. See paper for further details.

```{r}
if(specCodeMaxRatio != 127251) stop("Need common name; not Blackbelly Rosefish")
if(specCodeMaxWidth != 126436) stop("Need common name; not Atlantic Cod")

specNameHighlight = dplyr::filter(specCodeNames, speccode %in% specCodeHighlight)
specNameHighlight
```

TODO: *Triglops murrayi* is Moustache Sculpin (code 127205). *Lumpenus lampretaeformis* is Snakeblenny (code 154675). Data for these are
```{r highlight}
dataHighlight = dplyr::filter(data, SpecCode %in% specCodeHighlight)
dataHighlightSumm = dplyr::summarise(dplyr::group_by(dataHighlight, SpecCode),
    minLngt = min(LngtClass),
    maxLngt = max(LngtClass),
    LWa = unique(LWa),
    LWb = unique(LWb))
dataHighlightSumm
```


<!-- TODO: The body-mass bin with the biggest ratio of width to lower bound of the bin occurs for the Blackbelly Rosefish (\emph{\Sexpr{specNameMaxRatio}}) which is species code \Sexpr{specCodeMaxRatio}, indicated by $\times$ in Figure~\ref{fig:nSeaFungBins4} [not any more]. The bin goes from \Sexpr{round(dataBinSpec[rowMaxRatio, ]$wmin, dig=2)} to \Sexpr{round(dataBinSpec[rowMaxRatio, ]$wmax, dig=2)}~g, such that the ratio of bin-width to the lower bound is \Sexpr{round(dataBinSpec[rowMaxRatio, ]$wWidthRatio, dig=2)} (though this is hard to see in Figure~\ref{fig:nSeaFungBins4}). Consequently, in the earlier  analyses, all individuals of this species with a body-length of \Sexpr{dataBinMaxRatio$LngtMin}-\Sexpr{dataBinMaxRatio$LngtMax}~cm would get assigned a body length of \Sexpr{dataBinMaxRatio$LngtMin}~cm, and consequently a body mass of \Sexpr{round(dataBinMaxRatio$wmin, dig=2)}. However, the true possible range of body masses is \Sexpr{round(dataBinMaxRatio$wmin, dig=2)}-\Sexpr{round(dataBinMaxRatio$wmax, dig=2)}~g. Thus, individuals at the upper end of this range are being assigned body masses of about half of their actual body mass.-->

The widest resulting body-mass bin occurs for Atlantic Cod (`r
specNameMaxWidth`), which is species code `r specCodeMaxWidth`, the rightmost
species in the final figure above figure. The widest bin goes from `r
round(dataBinSpec[rowMaxWidth, ]$wmin, dig=0)` to `r
round(dataBinSpec[rowMaxWidth, ]$wmax, dig=0)` g, with a width of `r
round(dataBinSpec[rowMaxWidth, ]$wWidth, dig=0)` g.



<!-- \onefig{nSeaFungBins1}{Vertical blue bars show the body-mass bins that result from converting the 1-cm length bins into body-mass bins using the species-specific length-weight parameters. These are the first 45 species, ordered by the maximum value of the highest bin. Herring and sprat use 0.5-cm length bins, and their resulting body-mass bins are given by crosses (sprat is code \Sexpr{spratCode}). The vertical gaps between vertical bars indicate that there were no body masses of that species in that range (i.e. there were no individuals in the length bin that would result in the body-mass bin(s) that would fill the gap). The two red columns indicate two species that are explicitly discussed in the text.}

\onefig{nSeaFungBins2}{As for Figure~\ref{fig:nSeaFungBins1} but for the next 45 species -- note the different vertical axis scale from Figure~\ref{fig:nSeaFungBins1}.}

\onefig{nSeaFungBins3}{As for Figure~\ref{fig:nSeaFungBins1} but for the final 45 species -- note the different vertical axis scale from Figure~\ref{fig:nSeaFungBins1}. In some sense the tail containing rare large organisms, characteristic of a power-law distribution, shows up if you rotate the figure clockwise 90 degrees -- it somewhat resembles a power-law distribution.}

\onefig{nSeaFungBins4}{As for Figure~\ref{fig:nSeaFungBins3} but just for species with maximum body mass up to 10~kg to more clearly show their body-mass bins.}
-->

```{r echo=FALSE, eval=FALSE}
# Plot of wmax for each species. I think it's a metric used somewhere.
plot(1:(dim(dataBinSpecWmax)[1]),
     dataBinSpecWmax$maxWmax,
     log="y",
     xlab="Species index",
     ylab="Wmax for each species")

# Plot of maximum overall body size (max of max(wmax)) each year
maxWmaxByYear = dplyr::summarise(dplyr::group_by(dataBin, Year),
                                 maxWmax = max(wmax))
smallTck=0.01
yLimWmaxByYear = range(pretty(c(0, max(maxWmaxByYear$maxWmax))))
plot(maxWmaxByYear$Year,
     maxWmaxByYear$maxWmax,
     xlab="Year",
     ylab="Wmax for each year",
     ylim=yLimWmaxByYear)
xTicksSmall = maxWmaxByYear$Year
axis(1, at = xTicksSmall, labels = rep("", length(xTicksSmall)), tck=-smallTck)
yTicksSmall = seq(yLimWmaxByYear[1], yLimWmaxByYear[2], by=2000)
axis(2, at = yTicksSmall, labels = rep("", length(yTicksSmall)), tck=-smallTck)
# points(2011, dplyr::filter(maxWmaxByYear, Year == 2011)$maxWmax, col="red", pch=19)
```

## Likelihood calculations using new MLEbins method}

Now use the MLEbins method to fit each year of data in turn.

```{r MLEbins}
# Do a loop for each year, saving the results in MLEbins.nSeaFung.new
bstart = -1.9                   # just start close to -2,
fullYears = sort(unique(dataBin$Year))[1:3]  # ****TODO***** remove [1:3] - just
                                        # to make it run faster TODO

for(iii in 1:length(fullYears))
  {
    dataBinForLike = dplyr::filter(dataBin,
                                   Year == fullYears[iii])
    dataBinForLike = dplyr::select(dataBinForLike,
                                   SpecCode,
                                   wmin,
                                   wmax,
                                   Number)
    n = sum(dataBinForLike$Number)
    xmin = min(dataBinForLike$wmin)
    xmax = max(dataBinForLike$wmax)

    MLEbins.nSeaFung.oneyear.new  = calcLike(negLL.fn = negLL.PLB.bins.species,
                                             p = bstart,
                                             dataBinForLike = dataBinForLike,
                                             n = n,
                                             xmin = xmin,
                                             xmax = xmax)

    if(iii == 1)
    {
      MLEbins.nSeaFung.new = data.frame(Year = fullYears[iii],
                                        xmin=xmin,
                                        xmax=xmax,
                                        n=n,
                                        b=MLEbins.nSeaFung.oneyear.new$MLE,
                                        confMin=MLEbins.nSeaFung.oneyear.new$conf[1],
                                        confMax=MLEbins.nSeaFung.oneyear.new$conf[2])
    } else {
      MLEbins.nSeaFung.new = rbind(MLEbins.nSeaFung.new,
                                   c(fullYears[iii],
                                     xmin,
                                     xmax,
                                     n,
                                     MLEbins.nSeaFung.oneyear.new$MLE,
                                     MLEbins.nSeaFung.oneyear.new$conf[1],
                                     MLEbins.nSeaFung.oneyear.new$conf[2]))
   }
}

# Need the standard error for weighted linear regression.
#  [see eightMethods.count() for details]

MLEbins.nSeaFung.new = dplyr::tbl_df(MLEbins.nSeaFung.new)
MLEbins.nSeaFung.new = dplyr::mutate(MLEbins.nSeaFung.new,
                                     stdErr = (abs(confMin-b) +
                                               abs(confMax-b))/(2*1.96) )

# For double checking the confidence interval
# MLEbins.nSeaFung.new = dplyr::mutate(MLEbins.nSeaFung.new,
#                                     diff = confMax + confMin - 2*b)
#range(MLEbins.nSeaFung.new$diff)   # This should be small
#
#MLEbins.nSeaFung.new = dplyr::select(MLEbins.nSeaFung.new, -diff)
```

TODO - will prob break here

Now for Figure 8, comparing the results with the original MLE method: TODO don't
think this one is needed...
```{r timeseries, fig.width=7.5, fig.height=6}
yLim=c(-2.2, -0.9)
res = timeSerPlot(MLEbins.nSeaFung.new,
                  legName = "(a) MLEbins",
                  yLim = yLim,
                  xLab = "Year",
                  method = "MLEbins",
                  legPos = "bottomleft",
                  weightReg = TRUE,
                  xTicksSmallInc = 1,
                  yTicksSmallInc = 0.05)
```

And show the statistics for the regression fit, the final row in Table S.1:
TODO exclude unweighted results, and uncomment result.
TODO - change MLEbin to MLEbins in the following
```{r}
res
# just do res
# trendResultsMLEbinNew = dplyr::tbl_df(rbind(res, resNonWeight))
trendResultsMLEbinNew = dplyr::tbl_df(res)

# trendResultsMLEbinTabNew = xtable(dplyr::select(trendResultsMLEbinNew, -adjRsquared),
#  digits=c(1, 1, 5, 5, 5, 4, 4))

# print(trendResultsMLEbinTabNew, table.placement="tp", caption.placement="top",
#    include.rownames = FALSE, sanitize.text.function=function(x){x})  # was !ht
```

```{r fig.width=7.5, fig.height=6.3}
fullResults.MLEbins = MLEbins.nSeaFung.new  # TODO should have just used MLEbins..
trend.MLEbins.new = dplyr::filter(trendResultsMLEbinNew,
                                  Method == "MLEbins")
bYears = fullResults.MLE$Year
xLim = range(bYears)
yLim = c(-1.82, -1.35)
MLE.col = "blue"
MLEbins.col = "red"
res.MLE = timeSerPlot(fullResults.MLE,
                      legName = "",
                      xLim=xLim,
                      yLim=yLim,
                      xLab = "Year",
                      method = "MLE",
                      legPos = "bottomleft",
                      weightReg=TRUE,
                      bCol=MLE.col,
                      regPlot = FALSE,
                      regColNotSig = "lightblue",
                      regColSig="darkblue",
                      xTicksSmallInc = 1,
                      yTicksSmallInc = 0.02,
                      legExtra = c("MLEbins", "MLE"),
                      legExtraCol=c(MLEbins.col, MLE.col),
                      legExtraPos = "topleft",
                      xJitter = -0.03)       # MLEbins on top as values are higher in figure

res.MLEbins.new = timeSerPlot(fullResults.MLEbins,
                              legName = "",
                              method = "MLEbins",
                              weightReg=TRUE,
                              newPlot=FALSE,
                              bCol=MLEbins.col,
                              regPlot = FALSE,
                              regColNotSig = "pink",
                              regColSig="darkred",
                              xJitter = 0.03)
```

Finally, some further calculations to compare trends. This gives the ratio of
the estimates of *b* between the two methods:
```{r bRatio, fig.width=7.5, fig.height=6.3}
bRatio = fullResults.MLE$b / fullResults.MLEbins$b
xLim = range(bYears)
yLim = c(1, max(bRatio))
smallTck = 0.01

lm.bRatio = lm(bRatio ~ bYears)
yearInc = seq(xLim[1], xLim[2], 0.1)
p.conf.bRatio = predict(lm.bRatio,
                        newdata=data.frame(Year=bYears),
                        interval="confidence")
pVal.bRatio = summary(lm.bRatio)$coeff["bYears", 4]

plot( bYears,
     bRatio,
     xlab="Year",
     pch=19,
     ylab= expression(paste("(",
                            italic(b),
                            " from MLE)/(",
                            italic(b),
                            " from MLEbins)"),
                      sep=""),
     ylim = yLim)
xTicksSmall = seq(xLim[1], xLim[-1], by=1)
axis(1,
     at = xTicksSmall,
     labels = rep("", length(xTicksSmall)),
     tck=-smallTck)
yTicksSmall = seq(yLim[1], yLim[-1], by=0.05)
axis(2,
     at = yTicksSmall,
     labels = rep("", length(yTicksSmall)),
     tck=-smallTck)

if (pVal.bRatio > 0.05) regCol = "darkgrey" else regCol = "red"
lm.line(xLim, lm.bRatio, col=regCol)
matlines(bYears,
         p.conf.bRatio[ ,c("lwr", "upr")],
         col=regCol,
         lty=2)
confVals = confint(lm.bRatio, "bYears", level=0.95)
```
Above figure shows the annual ratio of the estimate of *b* using the original
MLE method to the estimate of *b* using the MLEbins method. The linear
regression slope is `r round(lm.bRatio$coeff[2],dig=5)` with 95\% confidence
interval `r round(confVals[1],dig=5)` to `r round(confVals[2],dig=5)}`, *p*=`r
round(pVal.bRatio, dig=5)`, *R*^2=`r round(summary(lm.bRatio)$r.squared, dig=3)`.


And this shows the difference of the estimates of *b* between the two methods.
```{r bDiff, fig.width=7.5, fig.height=6.3}
bDiff = fullResults.MLEbins$b - fullResults.MLE$b
yLim = range(pretty(bDiff))

lm.bDiff = lm(bDiff ~ bYears)
p.conf.bDiff = predict(lm.bDiff,
                       newdata=data.frame(Year=bYears),
                       interval="confidence")
pVal.bDiff = summary(lm.bDiff)$coeff["bYears",4]

plot(bYears,
     bDiff,
     xlab="Year",
     pch=19,
     ylab= expression(paste("(",
                            italic(b),
                            " from MLEbins) - (",
                            italic(b),
                            " from MLE)"),
                      sep=""),
     ylim = yLim)
xTicksSmall = seq(xLim[1], xLim[-1], by=1)
axis(1,
     at = xTicksSmall,
     labels = rep("", length(xTicksSmall)),
     tck=-smallTck)
yTicksSmall = seq(yLim[1], yLim[-1], by=0.01)
axis(2,
     at = yTicksSmall,
     labels = rep("", length(yTicksSmall)),
     tck=-smallTck)

if (pVal.bDiff > 0.05) regCol = "darkgrey" else regCol = "red"
lm.line(xLim, lm.bDiff, col=regCol)
matlines(bYears,
         p.conf.bDiff[ ,c("lwr", "upr")],
         col = regCol,
         lty=2)
confVals = confint(lm.bDiff, "bYears", level=0.95)
```
The above figure shows the annual difference of the estimate of *b* using
MLEbins to the estimate of *b* using the original MLE method. The linear
regression slope is `r round(lm.bDiff$coeff[2],dig=5)` with 95\% confidence
interval `r round(confVals[1],dig=5)` to `r round(confVals[2],dig=5)`, *p*=`r
round(pVal.bDiff, dig=5)`, *R*^2=`r round(summary(lm.bDiff)$r.squared, dig=3)`.

Finally, the actual results for each method, with the MLEbins table being Table
S.2:
TODO: use kable, first one might work, do the second one and edit to give Table S.2
```{r, eval=FALSE}
knitr::kable(dplyr::select(fullResults.MLE, -Method),
             caption="Full results for original MLE method.",
             lab="tab:fullresults.MLE",
             digits=c(0, 0, 3, 3, 3, 5))

#print(fullResults.MLEtab, table.placement="tp", caption.placement="top",
#    include.rownames = FALSE, sanitize.text.function=function(x){x})  # was !ht


fullResults.MLEbinsTab = xtable(
  # dplyr::select(fullResults.MLEbins, -n, -xmin, -xmax),
  fullResults.MLEbins,
  caption="Full results for MLEbins.",
  lab="tab:fullresults.MLEbins", digits=c(0, 0, 2, 2, 1, 3, 3, 3, 5))

# print(fullResults.MLEbinsTab, table.placement="tp", caption.placement="top",
#    include.rownames = FALSE, sanitize.text.function=function(x){x})  # was !ht
```

```{r save}
# TODO - work out what to save, just copy from data-raw I expect.
# save.image(file="nSeaMLEbins.RData")
```
