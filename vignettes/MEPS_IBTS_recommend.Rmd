---
title: "MEPS_IBTS_recommend"
author: "Andrew Edwards"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MEPS_IBTS_recommend}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5.7,
  fig.height = 7
)
```

# Recommended plotting approach from the MLEbins method

This vignette has some of the calculations used to explain the recommended
plotting approach, reproduces Figure S.4, Figure 7 [TODO check] and presents
Figures S.5 to S.34 as a movie [TODO: hopefully].

```{r}
library(sizeSpectra)
# library(tibble)  # Else prints all of a tibble
```



TODO: And see what to save in data-raw/??.R, copy those lines to end of here,
may not need to save anything new

Copying nSeaMLEbins-recommend.Snw, some already in other vignette so deleting
that out:


## Schematic diagram for two species

Picking two example species (coloured in red in Figure 6). Codes are 127205
(Moustache Sculpin) and 154675 (Snakeblenny).

```{r}
sculpin = 127205
snakeblenny = 154675
specForFig = c(snakeblenny, sculpin)

dataTwoSpec = dplyr::filter(dataBin, SpecCode %in% specForFig)
```

Combine the data across all years for illustrative purposes (to reduce the number
of empty bins in the illustration):
```{r combine}
dataComb = dplyr::summarise(dplyr::group_by(dataTwoSpec,
                                            SpecCode,
                                            wmin),
                            wmax = unique(wmax),
                            number = round(sum(Number), dig=4))
dataComb = dplyr::mutate(dataComb, j = min_rank(wmin))   # works since they're grouped
dataComb[nrow(dataComb), "j"] = 25                       # manually, because there's a gap
dataComb = dplyr::mutate(dataComb, wmid = (wmin + wmax)/2)  # midpoint for plotting
```

Now create Figures S.4, with semi-automated text for the caption:
```{r fig.width=6.5, fig.height=4}
target = 7                 # target bin (for species 2)    # TODO 7 to target in
                           # next two lines
target.wmin = dplyr::filter(dataComb,
                            SpecCode == specForFig[2],
                            j == 7)$wmin
target.wmax = dplyr::filter(dataComb,
                            SpecCode == specForFig[2],
                            j == 7)$wmax
# Smallest and then largest possible inclusions of being > target bin:
dataComb = dplyr::mutate(dataComb,
                         wmin.gt.tmax = (wmin >= target.wmax))
dataComb = dplyr::mutate(dataComb,
                         wmax.gt.tmin = (wmax > target.wmin))

xLim = c(15, 43)           # range to show, must be integers
dataComb = dplyr::filter(dataComb,
                         wmin > xLim[1])  # only show complete bins

numSpec = length(specForFig)
yLimMax = 1
yVals = c(0.3, 0.7)        # y values for horizontal mass bins

colSpec = c("red", "pink")
thick = 30                 # y thickness of bins
cex.sub = 0.7              # font size for subscripts

#postscript("binCountRangeSchematic.eps",
#           height = 4, width = 6.5,
#           horizontal=FALSE,  paper="special")
par(mgp=c(2.0, 0.5, 0))    # puts axes labels closer I think
par(lend="butt")           # To have butted line caps, need for thick lines.
par(mar = c(4, 2.5, 3, 2)) # outer margins

plot(0, 0, xlab="Body mass, g", ylab="", xlim=xLim,
     ylim=c(0, yLimMax), yaxt="n", type="n", xaxs="i") # set up axes.

axis(1, at = xLim[1]:xLim[2], labels = rep("", xLim[2]-xLim[1]+1), tck=-0.01)

mtext("Species Code", side=2, line=1.5, cex.lab=1)
axis(2, at = yVals, labels = c(1,2), las = 2,
        tck = -0.005, cex.axis=0.8)

abline(v = target.wmin, col = "grey")
abline(v = target.wmax, col = "grey")

for(ii in 1:length(specForFig))   # loop over species, plot bins for each
  {
    yVal = yVals[ii]         # where to have horizontal bars
    bins.wmin = dplyr::filter(dataComb, SpecCode == specForFig[ii])$wmin  # for this sp
    bins.wmax = dplyr::filter(dataComb, SpecCode == specForFig[ii])$wmax
    bins.wmid = dplyr::filter(dataComb, SpecCode == specForFig[ii])$wmid
    # bins for which wmin >= target.wmax
    bins.wmin.gt.tmax = dplyr::filter(dataComb, SpecCode == specForFig[ii])$wmin.gt.tmax
    bins.wmin.gt.tmax.yn = ifelse(bins.wmin.gt.tmax,"Y", "N")
    # bins for which wmax > target.wmin
    bins.wmax.gt.tmin = dplyr::filter(dataComb, SpecCode == specForFig[ii])$wmax.gt.tmin
    bins.wmax.gt.tmin.yn = ifelse(bins.wmax.gt.tmin,"Y", "N")

    segments(y0 = yVal,
             x0 = bins.wmin,
             x1 = bins.wmax,
             col=colSpec, lwd=thick)    # recycles col
    # Bin break labels (cannot do , with vector for labels, it seems):
    for(iiii in 1:length(bins.wmin))
      {
        text(x = bins.wmin[iiii],
             y = yVal,
             labels = bquote(paste(w[.(ii)*","*
                    .(dplyr::filter(dataComb, SpecCode == specForFig[ii])$j[iiii])])),
             pos = 1,
             offset = 0.03*thick,
             cex = cex.sub)
      }
    # Do final wmax manually:
    text(x = bins.wmax[length(bins.wmax)],
         y = yVal,
         labels = bquote(paste(w[.(ii)*","*
                     .(max(dplyr::filter(dataComb, SpecCode == specForFig[ii])$j)+1)])),
         pos = 1,
         offset = 0.03*thick,
         cex = cex.sub)
    # Put counts for each bin
    text(x = bins.wmid,
         y = yVal,
         labels = f(dplyr::filter(dataComb, SpecCode == specForFig[ii])$number, ii+1),
                  # ii+1 happens to give 3 d.p.s for species 2 and 2 for species 1,
                  #  as needed on figure
         pos = NULL,
         offset = 0.03*thick,
         cex = cex.sub*1.2)
    # Whether to include in counts
    eps = 0.23                  # Offset from wmid for Y's and N's
    text(x = bins.wmid - eps,
         y = yVal,
         labels = bins.wmin.gt.tmax.yn,
         pos = 3,
         offset = 0.03*thick,
         cex = cex.sub*1.2)
    text(x = bins.wmid + eps,
         y = yVal,
         labels = bins.wmax.gt.tmin.yn,
         pos = 3,
         offset = 0.03*thick,
         cex = cex.sub*1.2)
  }

# Need w_1,24 manually, assumes this is the only one with j=23
text(x = dplyr::filter(dataComb, j==23)$wmax,
     y = yVals[1],
     labels = bquote(paste(w[.(1)*","*24])),
     pos = 1,
     offset = 0.03*thick,
     cex = cex.sub)

# Calculations for the caption:
lowCount = sum(dataComb$wmin.gt.tmax * dataComb$number)
highCount = sum(dataComb$wmax.gt.tmin * dataComb$number)

```

```{r, animation.hook='gifski'}
for (i in 1:2) {
  pie(c(i %% 2, 6), col = c('red', 'yellow'), labels = NA)
}
```

Caption: Schematic diagram to explain how we calculate
  the range of counts of individuals that are larger than those in a given bin.
  Red and pink body-mass bins are those for Snakeblenny and Moustache Sculpin
  (labelled species 1 and 2, respectively) from Figure 5 in the paper.
  Bin breaks are denoted by $w_{s,j}$
  and the number inside each bin is the number observed per hour of trawling.
  For illustration data are combined across all years and only bins with
  minima $>15$ g are shown. The target bin has $s=2$ and $j=7$ and therefore
  has bin breaks $w_{2,7}$ and $w_{2,8}$ and is indicated by the vertical grey
  lines.
  The first letter in each pair (`NN', `NY', or `YY') denotes whether or not
  each bin is included in the low count $E_{2,7,1}$, i.e. its lower bound is
  $\geq$ the upper bound of the target bin. Similarly, the second letter denotes
  whether or not each bin is included in the high count $E_{2,7,2}$, i.e.
  its upper bound is $>$ the lower bound of the target bin. Summing the
  respective counts as per (TODO ref{Esj1}) and (TODO ref{Esj1}) gives
  $E_{2,7,1} =$`r f(lowCount,2)` and $E_{2,7,2} =$ `r f(highCount,2)`.

TODO:
Figure~ref{fig:binCountRangeSchematic} shows these calculations for
one `target' bin ($s=2, j=7$) and two
example species namely Moustache Sculpin and Snakeblenny (which are highlighted
as 127205 and 154675, respectively, in red in Figure~5). Remaining text already
copied into Supp Material.

## Results plotted for each year

First just get what's needed for the calculations for the recommended plot:
```{r recommended}
dataRecommend.isd = dplyr::select(dataBin,
                                  Year,
                                  wmin,
                                  wmax,
                                  Number)

xRange.global = c(min(dataRecommend.isd$wmin),
                  max(dataRecommend.isd$wmax))
data.year.list = list()                # to save results for each year
diff.ivec = vector()                   # to save i that have any cumSum !=
                                       # verify TODO
fullYears = sort(unique(dataBin$Year))
for(i in 1:length(fullYears))
  {
    data.year = dplyr::filter(dataRecommend.isd,
                              Year == fullYears[i])

    data.year = dplyr::arrange(data.year,
                               desc(wmin))
    sumNumber = sum(data.year$Number)
    data.year = dplyr::mutate(data.year,
                              cumSum = cumsum(Number))
    # Have to do not with dplyr
    wmin.vec = data.year$wmin
    wmax.vec = data.year$wmax
    num.vec = data.year$Number

    verify = rep(NA, length(num.vec)) # manual count originally to check that
                                      #  it equals cumSum - turns out not to as
                                      #  investigated below TODO decide what to
                                      #  include without getting confusing
    lowCount = verify
    highCount = verify
    for(iii in 1:length(verify))
    {
      verify[iii] = sum( (wmin.vec >= wmin.vec[iii]) * num.vec)
      lowCount[iii] = sum( (wmin.vec >= wmax.vec[iii]) * num.vec)
      highCount[iii] = sum( (wmax.vec > wmin.vec[iii]) * num.vec)
    }
    data.year = cbind(data.year,
                      "verify" = verify,
                      "lowCount" = lowCount,
                      "highCount" = highCount)
    data.year = dplyr::tbl_df(data.year)
    # See subsection below for manual look into these.
    if(sum(abs(data.year$cumSum - data.year$verify)) > 0)   #TODO
       diff.ivec = c(diff.ivec, i)
     #{stop(paste0("need to manually check for i=", i, ", year ", fullYears[i]))}
     # put that value of i into here (like i!=6), add a subsection, re-run
     #  to get this year's value into data.year.list and make conclusions in
     #  the subsection.
  data.year.list[[i]] = data.year
}

inset = c(0, 0)#-0.04)      # inset for (a) and (b)
inset2 = c(0, 0.04)         # inset for year

```


```{r, animation.hook='gifski', fig.width = 5.36, fig.height = 8}
# fig.width is 0.67 * fig.height (which is 8)
for (i in 1:2) {
  pie(c(i %% 2, 6), col = c('red', 'yellow'), labels = NA)
}

#  postscript(paste0(dirToSaveFigs, "/IBTS-ISD", fullYears[i], ".eps"),
#             height = figheight, width = figwidth,
#             horizontal=FALSE, paper="special")
for(i in 1:length(fullYears))   # TODO could make a function
{
  par(mfrow=c(2,1))
  par(mai=c(0.4, 0.5, 0.05, 0.3), cex=0.7)  # Affects all figures
  mgpVals = c(1.6,0.5,0)
  seg.col = "green"                         # colour for horizontal segments

  xRange = c(min(data.year$wmin), max(data.year$wmax)) # For PLB line, need
                                                       #  higher res for log axis
  x.PLB = seq(xRange[1], xRange[2], length=10000)
          # x values to plot PLB, need high resolution for both plots, but
          #  insert value close to xmax to make log-log curve go down further
  x.PLB.length = length(x.PLB)
  x.PLB = c(x.PLB[-x.PLB.length],
            0.99999 * x.PLB[x.PLB.length],
            x.PLB[x.PLB.length])
  y.PLB = (1 - pPLB(x = x.PLB,
                    b = dplyr::filter(MLEbins.res, Year == fullYears[i])$b,
                    xmin = min(x.PLB),
                    xmax = max(x.PLB))) * sumNumber
  # To add curves for the limits of the 95% confidence interval of b:
  y.PLB.confMin = (1 - pPLB(x = x.PLB,
                    b = dplyr::filter(MLEbins.res, Year == fullYears[i])$confMin,
                    xmin = min(x.PLB),
                    xmax = max(x.PLB))) * sumNumber
  y.PLB.confMax = (1 - pPLB(x = x.PLB,
                    b = dplyr::filter(MLEbins.res, Year == fullYears[i])$confMax,
                    xmin = min(x.PLB),
                    xmax = max(x.PLB))) * sumNumber

  # yRange = c(min(data.year$lowCount), max(data.year$highCount))
  # The above does not work because first val is 0 which is not permissable on
  #  log axis. Which also means that the rectangle that goes to 0 has to be
  #  added manually (below). Picking the y-axis to go down to 0.75 the verify
  #  value of the lowest bin (0.5 was a bit big). TODO edit that maybe
  yRange = c(0.75*min(data.year$verify), max(data.year$highCount))

  # y-axis not logged
  plot(data.year$wmin, data.year$verify,
       log="x",
       xlab=expression(paste("Body mass (", italic(x), "), g")),
       ylab=expression(paste("Number of ", values >= italic(x))),
       xlim = xRange.global,
       ylim = yRange,
       type = "n",
       axes = FALSE,
       mgp = mgpVals)

  xLim = 10^par("usr")[1:2]
  yLim = 10^par("usr")[3:4]

  logTicks(xLim,
           yLim=NULL,
           xLabelSmall = c(5, 50, 500, 5000))
  yBig = seq(0, yRange[2], 1000)  # May have to tweak for some years
  # Big labelled:
  axis(2, at= yBig, labels = yBig, mgp=mgpVals)
  # Small unlabelled:
  axis(2,
       seq(yBig[1], yRange[2]*1.1, by=250),
       labels=rep("", length(seq(yBig[1], yRange[2]*1.1, by=250))),
       tcl=-0.2,
       mgp=mgpVals)

  rect(xleft = data.year$wmin,
       ybottom = data.year$lowCount,
       xright = data.year$wmax,
       ytop = data.year$highCount,
       col = "grey")
  segments(x0=data.year$wmin,
           y0=data.year$verify,
           x1=data.year$wmax,
           y1=data.year$verify,
           col=seg.col)
  lines(x.PLB, y.PLB, col="red", lwd=2)  # Plot line last so can see it
  lines(x.PLB, y.PLB.confMin, col="red", lty=2)
  lines(x.PLB, y.PLB.confMax, col="red", lty=2)

  legend("topright", "(a)",
         bty="n",
         inset=inset)
  legend("topright",
         legend=fullYears[i],
         bty="n", inset=inset2)
  legend("topright",
         legend=paste0("b=", round(dplyr::filter(MLEbins.res, Year ==
                                                              fullYears[i])$b, 2)),
         bty="n",
         inset=2*inset2)
  # if(max(abs(sum(data.year$Number) - yRange[2])) > 0.001)
  #    stop("Check here that n=yRange[2]; comment out once done once.")
  legend("topright",
         legend=paste0("n=", round(yRange[2], 2)),
         bty="n",
         inset=3*inset2)

  # y-axis logged
  # empty plot:
  plot(data.year$wmin,
       data.year$verify,
       log="xy",
       xlab=expression(paste("Body mass (", italic(x), "), g")),
       ylab=expression(paste("Number of ", values >= italic(x))),
       xlim = xRange.global,
       ylim = yRange,
       type = "n",
       axes = FALSE,
       mgp = mgpVals)

  xLim = 10^par("usr")[1:2]
  yLim = 10^par("usr")[3:4]

  logTicks(xLim, yLim, xLabelSmall = c(5, 50, 500))

  rect(xleft = data.year$wmin,
       ybottom = data.year$lowCount,
       xright = data.year$wmax,
       ytop = data.year$highCount,
       col = "grey")

  # Need to manually draw the rectangle with lowCount = 0 since it doesn't
  #  get plotted on log-log plot
  extra.rect = dplyr::filter(data.year, lowCount == 0)
  # if(nrow(extra.rect) > 1) stop("Check rows of extra rect.")
  rect(xleft = extra.rect$wmin,
       ybottom = rep(0.01 * yRange[1], nrow(extra.rect)),
       xright = extra.rect$wmax,
       ytop = extra.rect$highCount,
       col = "grey")

  segments(x0=data.year$wmin,
           y0=data.year$verify,
           x1=data.year$wmax,
           y1=data.year$verify,
           col=seg.col)

  lines(x.PLB, y.PLB, col="red", lwd=2) #, lty=5)
  lines(x.PLB, y.PLB.confMin, col="red", lty=2)
  lines(x.PLB, y.PLB.confMax, col="red", lty=2)
  legend("topright", "(b)", bty="n", inset=inset)
}
```


<!--
TODO commented out to try and get it working
\subsection{Checking cumSum -- 1991 ($i=6$) didn't agree with verify calculation;
  see later for automated calculations for each year this occurs}

For $i=6$, year 1991, we get {\tt cumSum} and {\tt verify} differing by
-0.02941, because there are repeated {\tt wmin}$=31.84771$ values:
<<year1991>>=
data.1991 = dplyr::filter(dataBin, Year == 1991)
data.1991 = arrange(data.1991, desc(wmin))
data.1991 = dplyr::mutate(data.1991, cumSum = cumsum(Number))

dplyr::filter(data.1991, abs(wmin - 31.84771) < 0.00001)
@
Aha, so it's two different species with the same length-weight coefficients
and same length bins. This is allowed (we have already ensured that we don't
have multiple counts of the same species in the same length bin). So we should
use {\tt verify} to plot the horizontal values, not {\tt cumSum}. Not that you'd
see the (very occasional and very small) difference, and for such cases you'll
always get the segments (and the grey rectangles) on top of each other (can't
distinguish two separate species). For unbinned data the {\tt cumSum} may be best
as it shows up each data point.

\subsection{Check cumSum -- 1992 ($i=7$) didn't agree with verify calculation}

For $i=7$, year 1992, we get {\tt cumSum} and {\tt verify} differing in
a few places (was only in one for 1991). So do more automated code here
than that above, in case need to check other years also.
<<year1992>>=
diff.i = 7
diff.year = fullYears[diff.i]
data.one.year = data.year.list[[diff.i]]
data.diff = dplyr::filter(data.one.year, abs(cumSum - verify) > 0)
dataBin.diff = dplyr::filter(dataBin, Year == diff.year, wmin %in% data.diff$wmin)
# If it's again because two species have same length-weight coefficients then
#  should be able to manually spot that by arranging the rows:
arrange(dataBin.diff, LWa, LngtMin)
# The quick check is that the following is all TRUE (since species are different)
abs(diff(arrange(dataBin.diff, LWa, LngtMin)$SpecCode)) > 0.1
@

So, same issue as for 1991 -- species have the same length-weight coefficients.

\subsection{Check remaining years as they come up, but automate as looks
  like it may keep occuring}

This will print the year then the differences between {\tt cumSum} and
{\tt verify}, and give the maximum difference at the end. Take a look here
if necessary if the maximum difference ends up being big (much bigger than 10 say
given the large sample sizes). In practice it likely won't matter anyway
which way the figure will be plotted; just helpful to go into here for
understanding).
<<year.others>>=
max.abs.diff = numeric()        # maximum overall abs diff betw cumSum and verify
for(diff.i in diff.ivec)
  {
    diff.year = fullYears[diff.i]
    print(diff.year)
    data.one.year = data.year.list[[diff.i]]
    data.diff = dplyr::filter(data.one.year, abs(cumSum - verify) > 0)
    print(data.diff$cumSum - data.diff$verify)
    max.abs.diff = max(max.abs.diff,
                       max(abs(data.diff$cumSum - data.diff$verify)))
    dataBin.diff = dplyr::filter(dataBin, Year == diff.year, wmin %in% data.diff$wmin)
    # If it's again because two species have same length-weight coefficients then
    #  should be able to manually spot that by arranging the rows:
    # print(arrange(dataBin.diff, LWa, LngtMin))
    # The quick check is that the following is all FALSE and so sum = 0
    #  (since spp are different)
    if(sum(abs(diff(arrange(dataBin.diff, LWa, LngtMin)$SpecCode)) < 0.1) > 0)
      { stop(paste0("Not the same repeated species issue for ", diff.year,
                   " as for 1991."))
      }
  }
@

If no error messages and this sentence gets printed, then any differences between
{\tt cumSum} and {\tt verify} are due to multiple species having the same
length-weight coefficients. For reference, the maximum difference is
\Sexpr{round(max.abs.diff, 6)} -- see above for which year.

Biggest difference is in 1995, so just take a quick look at the details:

<<year.1995>>=
diff.i = 10
diff.year = fullYears[diff.i]
print(diff.year)
data.one.year = data.year.list[[diff.i]]
data.diff = dplyr::filter(data.one.year, abs(cumSum - verify) > 0)
# print(data.diff$cumSum - data.diff$verify)
#max.abs.diff = max(max.abs.diff,
#                       max(abs(data.diff$cumSum - data.diff$verify)))
dataBin.diff = dplyr::filter(dataBin, Year == diff.year, wmin %in% data.diff$wmin)
# If it's again because two species have same length-weight coefficients then
#  should be able to manually spot that by arranging the rows:
print(arrange(dataBin.diff, LWa, LngtMin))
@

So that (and 1996) are for species 126425 (Atlantic Herring) that has the
0.5-cm length bins. Which is actually another reason that {\tt cumSum} is
not actually the right thing to use. Will check in Issue \#24 that it hasn't
been used in any calculations (don't think it has). For the above example
it's actually {\tt verify} that is the lower value. This only affects the
plotting of the y-values of the segments, not the rectangles at all (and so
at the end of the day is not that important), but we use {\tt verify} in the
plots anyway.

\section{Commentary on the actual results}

The years for which the PLB model seems to visually fit fairly well, at least
up to 100~g where they all seem to break off, are 1992, 1995, 1997, 1999,
2000, 2006, 2008, 2009, 2010 and 2014. The 1999 one shows a good resolution
of the rectangles, including the right-most one.
More commentary will be written straight into the Supp Material, since will
then get edited and refined for the manuscript.

\isdfig{\Sexpr{fullYears[1]}}{Individual size distribution and MLEbins fit
            (red solid curve)
            with 95\% confidence intervals (red dashed curves, may be hard to
            see) for IBTS data in \Sexpr{fullYears[1]}.
            For each bin, the horizontal green line shows
            the range of body sizes,
            with value on the y-axis corresponding to the
            total number of individuals in bins whose minima are $\geq$ the
            bin's minimum.
            For each bin, the vertical span of the grey rectangle shows the
            possible range of the number of individuals with body mass
            $\geq$ the body mass of individuals in that bin (horizontal span
            is the same as for the green lines).
        }

\newcounter{loop}
% \forloop{loop}{\Sexpr{min(fullYears)}{\value{loop}<\Sexpr{max(fullYears)+1}}{\isdfig{\arabic{loop}}}{Caption to do**}       % 6 -> \Sexpr{max(fullYears)+1}}
\newcommand{\loopMax}{\Sexpr{max(fullYears)+1}}
\forloop{loop}{\Sexpr{fullYears[2]}}{\value{loop} < \loopMax}
        {\isdfig{\arabic{loop}}{Individual size distribution and MLEbins fit
            with 95\% confidence intervals for IBTS data in \arabic{loop}.
            Details as in Figure~\ref{fig:ISD-1986}.
        }}

% \isdfig{IBTS-ISDfigs/IBTS-ISD1990}{Caption here}

<<save>>=>>=
save.image(file="nSeaMLEbins-recommend.RData")
@
-->
