---
title: "MLEbin_recommend"
author: "Andrew Edwards"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MLEbin_recommend}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5.7,
  fig.height = 7
)
```

## Recommended fitting and plotting approach for data that are binned (with just one set of bin breaks)

```{r setup}
library(sizeSpectra)
# library(tibble)  # Else prints all of a tibble
```

This vignette is for data that are only available in standard binned form, with one
set of bin breaks (unlike the overlapping species-specific bins shown in MEPS
Fig. 7). For example, zooplankton data available in non-overlapping logarithmic
scaled bins. Or, data that are only available in digitised form from earlier studies.

This vignette shows how to fit the PLB disribution (using the
MLEbin method) and plot it in a similar way to the MEPS Fig. 7. The plotting is
done using the new function `ISD_bin_plot_nonoverlapping()`, which is a wrapper
for the more complex (and now updated) `ISD_bin_plot()`.

There are two options depending how your data are stored. GOT TO HERE - divide
the next parts into two.

### Option 1 -- a vector of bin breaks and a vector of bin counts

Generate simulated data and bin it:
```{r generate}
x <- rPLB(1000,
          b = -2,
          xmin = 1,
          xmax = 1000)

binType = "2k"    # one of (1, 5, 10, "2k")

x.binned <- binData(x,
                    binWidth = binType)  # 1, 2, 5 or "2k"
head(x.binned$indiv)     # Individual x values and which bin they are assigned to
x.binned$binVals         # Bins and the counts in each bin

num.bins <- nrow(x.binned$binVals)

# bin breaks are the minima plus the max of the final bin:
binBreaks <- c(dplyr::pull(x.binned$binVals, binMin),
               dplyr::pull(x.binned$binVals, binMax)[num.bins])

binCounts <- dplyr::pull(x.binned$binVals, binCount)

MLEbin.res <-  calcLike(negLL.PLB.binned,
                        p = -1.5,
                        w = binBreaks,
                        d = binCounts,
                        J = length(binCounts),   # = num.bins
                        vecDiff = 1)             # increase this if hit a bound
```
Real data should be in the same form as above - basically a vector `binBreaks`
of breakpoints, and a vector `binCounts` of counts in each bin. There should be
one less component in `binCounts`, because `binBreaks` includes the endpoints of
all the bins.

If the real data are already in a tibble format, then

```{r, fig.width = 5.36, fig.height = 8}
# fig.width is 0.67 * fig.height (which is 8)
ISD_bin_plot_nonoverlapping(binBreaks = binBreaks,
                            binCounts = binCounts,
                            b.MLE = MLEbin.res$MLE,
                            b.confMin = MLEbin.res$conf[1],
                            b.confMax = MLEbin.res$conf[2])
```
